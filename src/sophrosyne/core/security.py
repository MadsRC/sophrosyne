"""Security module for the SOPH API.

This module contains the security-related functions for the SOPH API service.
It provides functions for generating tokens and signing data.

On Authentication:
    This module also provides the means with which to authenticate users by
    their tokens. As we need to identify a user solely by their token, using a
    per-user salt is un-tenable as it would require us to iterate over all
    users, while hashing the key with the users salt to find the user that the
    token matches. Instead, we use a keyed HMAC signature to sign the token,
    which allows us to verify the token without needing to iterate over all
    users.

    Using keyed functions for authentication is a recommendation by OWASP, from
    their Password Storage Cheat Sheet: https://owasp.deteact.com/cheat/cheatsheets/Password_Storage_Cheat_Sheet.html#leverage-keyed-functions

    The HMAC signature is generated by hashing the token with a secret site-wide
    key, and a site-wide salt. The salt is used to prevent rainbow table
    attacks, while the secret key is used to prevent brute-force attacks. The
    salt and site-wide key is provided via the settings, and should be kept
    secret.
"""

import datetime
import hashlib
import hmac
import ipaddress
import tempfile
from secrets import token_bytes, token_hex

from cryptography import x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.x509.oid import NameOID

from sophrosyne.core.config import get_settings


def new_token() -> str:
    """Generate a new token used for authentication.

    Returns:
        str: The new token.
    """
    return token_hex(get_settings().security.token_length)


def sign(data: str) -> str:
    """Sign the data using the HMAC signature.

    Args:
        data (str): The data to sign.

    Returns:
        str: The HMAC signature of the data.
    """
    settings = get_settings()
    secret_key = settings.security.site_key
    salt = settings.security.salt
    return (
        settings.security.salt.hex()
        + hmac.new(secret_key, salt + data.encode(), hashlib.sha256).hexdigest()
    )


class TLS:
    """TLS class for the SOPH API.

    This class contains the logic to create a TLS context for the SOPH API service.
    """

    certificate: x509.Certificate
    private_key: ec.EllipticCurvePrivateKey
    private_key_password: bytes
    public_key: ec.EllipticCurvePublicKey

    def __init__(
        self,
        certificate_path: str | None = None,
        key_path: str | None = None,
        key_password: bytes | None = None,
    ):
        """Initializes the TLS class."""
        if key_path is not None:
            with open(key_path, "rb") as file:
                k = serialization.load_pem_private_key(
                    file.read(), password=key_password, backend=default_backend()
                )
                if isinstance(k, ec.EllipticCurvePrivateKey):
                    self.private_key = k
                else:
                    raise ValueError("Key is not an EllipticCurvePrivateKey")
        else:
            self.private_key = ec.generate_private_key(
                ec.SECP256R1(), default_backend()
            )
        if key_password is None:
            key_password = token_bytes(128)

        # We do not reuse the key password, as it is not required after the key
        # is loaded. A new one is generated and stored in the class for use if
        # there is a need to write the key to persistent storage.
        self.private_key_password = key_password
        self.public_key = self.private_key.public_key()

        if certificate_path is not None:
            with open(certificate_path, "rb") as file:
                self.certificate = x509.load_pem_x509_certificate(
                    file.read(), default_backend()
                )
        else:
            self.generate_certificate(get_settings().hostnames)

    def generate_certificate(self, hostnames=list[str]):
        """Generates a new certificate."""
        if self.private_key is None:
            raise ValueError("Key is required to generate a certificate.")
        cert_builder = x509.CertificateBuilder()
        cert_builder = cert_builder.issuer_name(
            x509.Name(
                [
                    x509.NameAttribute(NameOID.COMMON_NAME, hostnames[0]),
                ]
            )
        )
        cert_builder = cert_builder.subject_name(
            x509.Name(
                [
                    x509.NameAttribute(NameOID.COMMON_NAME, hostnames[0]),
                ]
            )
        )
        cert_builder = cert_builder.serial_number(x509.random_serial_number())
        cert_builder = cert_builder.not_valid_before(datetime.datetime.utcnow())
        cert_builder = cert_builder.not_valid_after(
            datetime.datetime.utcnow() + datetime.timedelta(days=365)
        )
        cert_builder.add_extension(
            x509.BasicConstraints(ca=False, path_length=None), critical=True
        )
        for host in hostnames:
            try:
                ipaddress.ip_address(host)
                cert_builder = cert_builder.add_extension(
                    x509.SubjectAlternativeName(
                        [x509.IPAddress(ipaddress.ip_address(host))]
                    ),
                    critical=False,
                )
            except ValueError:
                cert_builder = cert_builder.add_extension(
                    x509.SubjectAlternativeName([x509.DNSName(host)]), critical=False
                )
        cert_builder = cert_builder.public_key(self.public_key)
        self.certificate = cert_builder.sign(
            private_key=self.private_key,
            algorithm=hashes.SHA256(),
            backend=default_backend(),
        )

    def to_path(
        self,
        input: x509.Certificate | ec.EllipticCurvePrivateKey,
    ) -> str:
        """Converts the input to a path.

        Args:
            input (Union[x509.Certificate, ec.EllipticCurvePrivateKey]): The input to convert.

        Returns:
            str: The path to the input.
        """
        with tempfile.NamedTemporaryFile(delete=False) as temp:
            if isinstance(input, x509.Certificate):
                temp.write(
                    input.public_bytes(
                        encoding=serialization.Encoding.PEM,
                    )
                )
            elif isinstance(input, ec.EllipticCurvePrivateKey):
                temp.write(
                    input.private_bytes(
                        encoding=serialization.Encoding.PEM,
                        format=serialization.PrivateFormat.TraditionalOpenSSL,
                        encryption_algorithm=(
                            serialization.BestAvailableEncryption(
                                password=self.private_key_password
                            )
                        ),
                    )
                )
            return temp.name
